---
title: "R.ROSETTA tutorials"
output:
  html_document:
      fig_caption: yes
      theme: paper
      highlight: pygments
      toc: true
      toc_float:
        collapsed: true
      toc_depth: 3
---

This is a collection of tutorials that will show you how to use the R.ROSETTA package.

# Installation
Installation from github requires devtools package:

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
install.packages("devtools")
```
Installation and loading R.ROSETTA package from github:

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
library(devtools)
install_github("komorowskilab/R.ROSETTA")
library(R.ROSETTA)
```

***
# Sample data
## Synthetic
You can create synthetic decision table with predefined correlation. Let's assume that we want to create a decision table with 100 objects and 20 features that level of correlation is 0.5. The outcome is balanced and has two decision classes. To generate such synthetic data, type:

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
dt <- synData(nFeatures=20, R=0.5, nObjects=100, nOutcome=2, unbalanced=F, seed=1)
```

Now we add double correlated features at the level of 0.1 and 0.7, and triple correlated features at the level of 0.8 and 0.2. We may set numeric vectors as our parameters:
```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
dt <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, unbalanced=F, seed=1)
```

## Gene expression
The package contains also gene expression dataset from case-control studies for autism prediction. The dataset exists as a `data.frame` named `autcon`.
```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
dt <- autcon
```

***
# Input format
The input is a decision table in a form of `data.frame`, where the columns represent features and rows represent objects. In the table last column shall contain the decision classes.
```{r, echo = FALSE, warning=FALSE, message=FALSE, results='asis'}
library(knitr)
library("kableExtra")

r1=c("...", "...", "...", "...","case")
r2=c("...", "...", "...", "...","control")
r3=c("...", "...", "...", "...","case")
r4=c("...", "...", "...", "...","...")
r5=c("...", "...", "...", "...","case")
tab1=rbind(r1, r2, r3, r4, r5)
colnames(tab1)<-c("feature_1", "feature_2", "...","feature_n","outcome")
rownames(tab1)<-c("object_1", "object_2", "object_3","...","object_n")
kable(tab1, format="html",  caption = "Decision table format") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```
To deal with complex decision tables we suggest to use feature selection methods.

***
# Running data
The main function to run R.ROSETTA is `rosetta()`. The default parameters of the function are set for the processing of sample datasets.

## Continuous
To create rough set-based models from continuous data, type: 
```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
# synthetic data
dt <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, unbalanced=F, seed=1)
out_s <- rosetta(dt)

# gene expression data
out_ge <- rosetta(autcon)
```

For the function parameters look at the R manual.

## Discrete
If you decision table contains all discrete features please use option `discrete=TRUE`.
Here is the example on synthetic data how to process discrete values.

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
dt <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, unbalanced=F, seed=1)
dt2 <- dt[,-length(dt)]
decision <- as.character(dt[,length(dt)])
dt2 <- sapply(dt2, function(x) cut(x,3, labels = F)) 
dt3 <- as.data.frame(cbind(dt2, decision))
out <- rosetta(dt, discrete = T)
```

## Mixed
For data containing a mixture of continuous and discrete features, please use option `discrete=FALSE` and assign following object type to the features:

  + Continuous features that require discretization: `numeric`
  + Discrete features: `character`, `factor`, `logical`

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
dt <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, unbalanced=F, seed=1)
# change the pair of features with R=0.1 to discrete values
dt$F1_G2_R0.1<-as.factor(cut(dt$F1_G2_R0.1,3, labels = c("low","medium","high"))) #or as.character
dt$F2_G2_R0.1<-as.factor(cut(dt$F2_G2_R0.1,3, labels = c("low","medium","high"))) #or as.character
out <- rosetta(dt, discrete = F)
```

***
# Output
There are two main outputs generated by `rosetta()`.

## Main
The main output of the function contains a collection of rules in a table. The rule components and all statistics values are collected in separate columns. The individual values are comma separated.

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
dt <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, 
out <- rosetta(dt)
out$main
```
```{r, echo = FALSE, warning=FALSE, message=FALSE, results='asis'}
library(knitr)
library("kableExtra")

r1=c("F1,F2", "1,2", "case", "43","0.97","0.174","...","...")
r2=c("F2,F4,F5", "2,1,3", "control", "40","0.95","0.142","...","...")
r3=c("F2", "3", "case", "36","0.89","0.097","...","...")
r4=c("...", "...", "...", "...","...","...","...")
r5=c("F7,F1", "3,1", "control", "10","0.64","0.014","...","...")
tab1=rbind(r1, r2, r3, r4, r5)
colnames(tab1)<-c("features", "levels", "decision","support","accuracy","coverage","cuts","statistics")
rownames(tab1)<-c("rule_1", "rule_2", "rule_3","...","rule_n")
kable(tab1, format="html",  caption = "Main output") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

## Quality
For the model quality the accuracy and AUC values are estimated. The values are taken from n-fold Cross-Validation process.

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
dt <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, 
out <- rosetta(dt)
out$quality
```
```{r, echo = FALSE, warning=FALSE, message=FALSE, results='asis'}
library(knitr)
library("kableExtra")
dt <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, unbalanced=F, seed=1)
out <- rosetta(dt)
# out$quality
kable(out$quality, format="html",  caption = "Model quality") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```
***

# Print rules
As the main output of rosetta consist a table of rule components, we may want to print rules in a classic IF-THEN form. To do this, use `viewRules()` function.

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
out <- rosetta(autcon)
rules <- out$main
vRules <- viewRules(rules)
head(vRules)
```
```{r, echo = FALSE, warning=FALSE, message=FALSE, results='asis'}
library(knitr)
library("kableExtra")
kable(head(vRules), format="html",  caption = "Print rules") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, position = "left")
```

***

# Recalculate model
R.ROSETTA allows to recalculate your model according to the input decision table. This step may be used to retrieve a statistics in case of performing undersampling and/or corss-validation.

Let's consider that one of our rules has support 24 and accuracy 0.92. These values come from the model that was divided into smaller training sets due to balancing process. Thanks to the model recalculation we obtain support 32 and accuracy 0.95, which is the value corresponding to the whole table. To recalculate model, run `recalculateRules()` function:

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
dt <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, unbalanced=F, seed=1)
out <- rosetta(dt)
rules <- out$main
newRules <- recalculateRules(dt, rules)
```

Additionally model recalculation calculates support sets, which are stored in the last columns of output.
***

# Plot rule
We can visualize a specific rule in form of a heatmap or boxplot. The plot is showing a distribution of values for three support groups. This visualization is done only after recalculating the model.

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=TRUE}
out <- rosetta(autcon)
rules <- out$main
newRules <- recalculateRules(autcon, rules)
#rule heatmap
plotRule(autcon, newRules, type = "heatmap", ind = 1)

#rule boxplot
plotRule(autcon, newRules, type = "boxplot", ind = 1)
```

***

# Predict unseen data
To test your model on external data you can use `predictClass()` function. The algorithm checks if the cuts or levels correspond to the external dataset. Make sure that feature names correspond to the names used in the model.

```{r, echo = TRUE, fig.align='center', warning=FALSE, eval=FALSE}
###prepare two datasets
##1. to create a model
dt1 <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=100, nOutcome=2, unbalanced=F, seed=1)
##2. to validate our model (different seed, less objects)
dt2 <- synData(nFeatures=c(20,2,2,3,3), R=c(0.5,0.1,0.7,0.8,0.2), nObjects=50, nOutcome=2, unbalanced=F, seed=2)
#store decision
dt2_decision <- dt2$decision
#remove decision from table
dt2 <- dt2[,-length(dt2)]

out <- rosetta(dt1)
rules <- out$main
newRules <- recalculateRules(dt1, rules)

# we can predict new classes if we don't have outcome
predictClass(dt2, newRules)
# if we know the decision, we can obtain the accuracy of prediction
predictClass(dt2, newRules, validate = TRUE, valiDec = dt2_decision)
```